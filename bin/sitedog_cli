#!/usr/bin/env ruby

require 'bundler/setup'
require 'sitedog_parser'
require 'optparse'
require 'logger'

# Set default options
options = {
  debug: false,
  pretty: true,
  compact_children: false,
  output: nil,
  log_level: Logger::INFO
}

# Create logger
logger = Logger.new(STDOUT)
logger.formatter = proc do |severity, datetime, progname, msg|
  "#{msg}\n"
end

# Command line options parser
option_parser = OptionParser.new do |opts|
  opts.banner = "Usage: sitedog_cli [options] <path_to_yaml_file> [output_file]"

  opts.on("-d", "--debug", "Enable debug output") do
    options[:debug] = true
    options[:log_level] = Logger::DEBUG
  end

  opts.on("-c", "--compact", "Output compact JSON (without pretty formatting)") do
    options[:pretty] = false
  end

  opts.on("--compact-children", "-C", "Format JSON with compact inner objects (one line per service)") do
    options[:compact_children] = true
  end

  opts.on("-q", "--quiet", "Suppress non-error messages") do
    options[:log_level] = Logger::ERROR
  end

  opts.on("-h", "--help", "Show this help message") do
    puts opts
    exit
  end
end

# Parse options
option_parser.parse!(ARGV)

# Set logging level
logger.level = options[:log_level]

# Check command line arguments
if ARGV.empty? || ARGV.size < 1 || ARGV.size > 2
  logger.error option_parser.help
  exit 1
end

file_path = ARGV[0]
output_path = ARGV[1]

# Check if input file exists
unless File.exist?(file_path)
  logger.error "Error: File '#{file_path}' not found."
  exit 1
end

# Redirect STDERR to hide debug output if not in debug mode
unless options[:debug]
  original_stderr = $stderr.dup
  $stderr.reopen(File.open(File::NULL, 'w'))
end

# Format JSON with inner objects on a single line
def compact_json_generate(data)
  # Clone data to avoid modifying the original
  formatted_data = Marshal.load(Marshal.dump(data))

  # Process each domain
  formatted_data.each do |domain_key, services|
    # For each service type
    services.each do |service_type, service_array|
      if service_array.is_a?(Array)
        # Convert service array to compact format
        services[service_type] = service_array.map do |service_obj|
          # Remove empty children arrays for compactness
          if service_obj['children'] && service_obj['children'].empty?
            service_obj.delete('children')
          end
          service_obj
        end
      end
    end
  end

  # Convert to JSON with indentation at top level, but compact inner objects
  output = "{\n"

  formatted_data.each_with_index do |(domain, services), domain_index|
    output << "  \"#{domain}\": {\n"

    services.keys.sort.each_with_index do |service_type, service_index|
      service_data = services[service_type]

      # Start line with service type
      output << "    \"#{service_type}\": "

      # Special formatting for service arrays - on a single line
      if service_data.is_a?(Array)
        items = service_data.map { |item| JSON.generate(item) }.join(",")
        output << "[#{items}]"
      else
        # For non-arrays use standard JSON.generate
        output << JSON.generate(service_data)
      end

      # Add comma for all elements except the last one
      output << (service_index < services.keys.size - 1 ? ",\n" : "\n")
    end

    output << "  }"
    output << (domain_index < formatted_data.size - 1 ? ",\n" : "\n")
  end

  output << "}"
  output
end

begin
  logger.debug "Processing file: #{file_path}"

  # Convert YAML to JSON
  data = SitedogParser::Parser.to_hash(file_path, { logger: logger })
  logger.debug "Data converted to hash"

  # Convert to JSON based on formatting options
  json_data = if options[:compact_children]
                logger.debug "Generating JSON with compact inner objects"
                compact_json_generate(data)
              elsif options[:pretty]
                logger.debug "Generating pretty JSON"
                JSON.pretty_generate(data)
              else
                logger.debug "Generating compact JSON"
                JSON.generate(data)
              end

  # If output file is specified, save result to it
  if output_path
    logger.debug "Saving to file: #{output_path}"
    File.write(output_path, json_data)
    logger.info "JSON data successfully saved to '#{output_path}'."
  else
    # Otherwise print JSON to screen
    # Use puts directly for JSON output to avoid logger prefixes
    puts json_data
  end

rescue => e
  # Restore STDERR for error messages
  $stderr.reopen(original_stderr) unless options[:debug]

  logger.error "Error processing file: #{e.message}"
  logger.debug e.backtrace.join("\n") if options[:debug]
  exit 1
ensure
  # Restore STDERR
  $stderr.reopen(original_stderr) unless options[:debug]
end